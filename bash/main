# .bash/main - Main Bash configuration
#
# This file is sourced from ~/.profile to pull in all custom shell configurations.
#
# Large portions taken from a variety of sources, including the dotfiles repos of
# github.com/{isaacs,rtomayko,twerth,sontek} to name a few.
#

main()
{
# try to avoid polluting the global namespace with lots of garbage.
# the *right* way to do this is to have everything inside functions,
# and use the "local" keyword.  But that would take some work to
# reorganize all my old messes.  So this is what I've got for now.
__garbage_list=""
__garbage () {
  local i
  if [ $# -eq 0 ]; then
    for i in ${__garbage_list}; do
      unset $i
    done
    unset __garbage_list
  else
    for i in "$@"; do
      __garbage_list="${__garbage_list} $i"
    done
  fi
}
__garbage __garbage


##
# Path utilities.

__garbage __set_path
__set_path () {
  local var="$1"
  local orig=$(eval 'echo $'$var)
  IFS=:
  orig=($orig)
  local p="$2"

  local path_elements=($p)
  unset IFS
  p=""
  local i
  local fixed
  for i in "${orig[@]}"; do
    if [ -d "$i" ]; then
      fixed="$fixed:$i"
    fi
  done
  fixed=" ${fixed//:/ : } :"
  for i in "${path_elements[@]}"; do
    if [ -d "$i" ]; then
      p="$p:$i"
      # strip out from the original set.
      fixed=${fixed/ $i :/}
    fi
  done
  fixed=${fixed// :/:}
  fixed=${fixed//: /:}
  fixed=${fixed%:}
  p="${p/:/}:$(echo ${fixed/:/})"
  export $var="$(echo $p)"
}

__garbage __form_paths
local path_roots=( "$HOME/" "$HOME/.local/" /usr/local/ /opt/local/ /usr/ /opt/ / )
__form_paths () {
  local r p paths
  paths=""
  for r in "${path_roots[@]}"; do
    for p in "$@"; do
      paths="$paths:$r$p"
    done
  done
  echo ${paths/:/} # remove the first :
}

__set_path PATH ".:$(__form_paths bin sbin)"
__set_path LD_LIBRARY_PATH "$(__form_paths lib)"
# TODO: Needs mingw path fixup
#__set_path CLASSPATH "."
__set_path CDPATH ".:..:$HOME/git:$HOME/hg:$HOME/svn:$HOME"


##
# Shell and host environment.

# detect interactive shell
case "$-" in
  *i*) INTERACTIVE=yes ;;
  *)   unset INTERACTIVE ;;
esac

# detect login shell
case "$0" in
  -*) LOGIN=yes ;;
  *)  unset LOGIN ;;
esac

# detect remote shell
if [ -n "$SSH_CONNECTION" ]; then
  REMOTE=yes
else
  unset REMOTE
fi

# Kernel and system identification.
# Don't set any variables named OS, OS_TYPE, or HOSTTYPE, these may already exist.
# Strip any numbers trailing the kernel, i.e. remove "32..." from "mingw32..."
HOST_OS=`uname -s | sed -e 's/  */-/g;y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/;s/[0-9].*//'`
HOST_MACHINE=`uname -m | sed -e 's/  */-/g;y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'`
HOST_VERSION=`uname -r`; HOST_VERSION=`expr "$HOST_VERSION" : '[^0-9]*\([0-9]*\.[0-9]*\)'`
HOST_PLATFORM="${HOST_MACHINE}-${HOST_OS}-${HOST_VERSION}"


##
# Locale

: ${LANG:="en_US.UTF-8"}
: ${LANGUAGE:="en"}
: ${LC_CTYPE:="en_US.UTF-8"}
: ${LC_ALL:="en_US.UTF-8"}
export LANG LANGUAGE LC_CTYPE LC_ALL


##
# Various shell options

export HISTSIZE=10000
export HISTFILESIZE=1000000000
export HISTCONTROL=ignoreboth
export HISTIGNORE="&:cd:ls:ll:la:lal:[bf]g:exit:clear:pwd"
export HISTTIMEFORMAT='%F %T '

if [ -n "$BASH" ]; then
  # see http://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html#The-Shopt-Builtin
  shopt -s cdspell                  # fix minor cd errors
  shopt -s checkhash                # check that a command exists in the hash table before executing it
  shopt -s checkwinsize             # update LINES and COLUMNS after each command to detect window size changes
  shopt -s cmdhist                  # save a multi-line command in a single history entry
  shopt -s expand_aliases           # expand aliases when not interactive
  shopt -s histappend               # append history instead of overwriting it
  shopt -s hostcomplete             # attempt hostname completion (on words containing '@')
  shopt -s nocaseglob               # case-insensitive filename match
  shopt -s no_empty_cmd_completion  # don't search PATH for command completion if the line is empty
fi


##
# Terminal

if [ -n "$REMOTE" ]; then
  # Fix the terminal when shelling in from MSYS or Cygwin.
  case "$TERM" in
    msys*)
      # TODO: Make sure the host isn't MSYS or Cygwin.
      export TERM=xterm
      ;;
  esac
fi


##
# Prompt

# Only set the prompt if the shell is interactive.
# The bash-complete function will set BASH_COMPLETE_INVOKE to prevent the prompt from being set;
# this is so it can detect the output of shell completion.
if [ -n "$INTERACTIVE" -a -z "$BASH_COMPLETE_INVOKE" ]; then
  # Colors defined by the Solarized color scheme.
  #__garbage NO_COLOR RED ORANGE GREEN YELLOW BLUE MAGENTA VIOLET CYAN WHITE
  NO_COLOR='\033[00m'
  RED='\033[00;31m'
  ORANGE='\033[01;31m'
  GREEN='\033[0;32m'
  YELLOW='\033[0;33m'
  BLUE='\033[00;34m'
  MAGENTA='\033[00;35m'
  VIOLET='\033[01;35m'
  CYAN='\033[00;36m'
  WHITE='\033[01;37m'

  PATH_COLOR=$YELLOW
  HOST_COLOR=$VIOLET

  function __prompt()
  {
    local cwd=${PWD/$HOME/\~}

    if [ -z "$1" ]; then
      echo -e "$(__prompt title)\n$(__prompt host):$(__prompt path)$(__prompt git)$(__prompt venv)"
    fi

    case "$1" in
      title)
        echo -ne "\033]0;$HOSTNAME:$cwd\007"
        ;;

      path)
        local path=$cwd
        if [ ${#path} -gt 40 ]; then
          local d=$(basename "$path")
          path=$(dirname "$path")
          local i=$[ ${#path} - 40 ]
          path=...${path:$i}/$d
        fi
        echo -ne "${PATH_COLOR}${path}${NO_COLOR}"
        ;;

      host)
        local user=${USER:-$USERNAME}
        local host=${HOSTNAME%%.*}
        echo -ne "${HOST_COLOR}${user}@${host}${NO_COLOR}"
        ;;

      time)
        echo -ne "[${GREEN}$(date +"%R")${NO_COLOR}]"
        ;;

      git)
        # From bronson's dotfiles:
        local STATE_COLOR=$WHITE
        local unclean_state="${STATE_COLOR}*"
        local changes_to_push="${STATE_COLOR}↑"
        local changes_to_pull="${STATE_COLOR}↓"
        local changes_to_push_and_pull="${STATE_COLOR}↕"

        local git_status="$(git status 2> /dev/null)"
        local branch_pattern="^(# )?On branch ([[:graph:]]*)"
        local remote_pattern="(# )?Your branch is (.*) of"
        local diverge_pattern="(# )?Your branch and (.*) have diverged"

        if [[ ! ${git_status} =~ "working directory clean" ]]; then
          local state="$unclean_state"
        fi

        # add an else if or two here if you want to get more specific
        if [[ ${git_status} =~ ${remote_pattern} ]]; then
          if [[ ${BASH_REMATCH[2]} == "ahead" ]]; then
            local remote="$changes_to_push"
          else
            local remote="$changes_to_pull"
          fi
        fi
        if [[ ${git_status} =~ ${diverge_pattern} ]]; then
          local remote="$changes_to_push_and_pull"
        fi
        if [[ ${git_status} =~ ${branch_pattern} ]]; then
          local branch=${BASH_REMATCH[2]}
          local git_branch=" (${branch})${remote}${state}"
        fi

        echo -ne "${MAGENTA}${git_branch}${NO_COLOR}"
        ;;

      venv)
        # From mitsuhiko's dotfiles:
        local ENV_NAME
        local folder
        if [ x"$VIRTUAL_ENV" != x ]; then
          if [[ "$VIRTUAL_ENV" == *.virtualenvs/* || "$VIRTUAL_ENV" == *.virtualenvs\\* ]]; then
            ENV_NAME=`basename "${VIRTUAL_ENV}"`
          else
            folder=`dirname "${VIRTUAL_ENV}"`
            ENV_NAME=`basename "$folder"`
          fi
          echo -ne " ${WHITE}workon ${GREEN}${ENV_NAME}${NO_COLOR}"
        fi
        ;;

      color)
        local color
        if [ $__prompt_status -eq 0 ]; then
          color="${NO_COLOR}"
        else
          color="${RED}"
        fi
        echo -ne "$color"
        ;;
    esac
  }

  PROMPT_COMMAND="__prompt_status=\$?; history -a; __prompt"
  PS1="\[\$(__prompt color)\]\$\[${NO_COLOR}\] "
fi


# List of file prefixes and extensions to ignore when doing autocomplete.
# Separate each extension with ':'.
export FIGNORE=.pyc

if [[ "$HOST_OS" == "mingw" ]]; then
  # Ignore the long and unused NTUSER.DAT{* files on Windows.
  export FIGNORE="$FIGNORE:.TM.blf:.regtrans-ms"
fi


##
# Functions and aliases

[ -f ~/.bash/functions ] && . ~/.bash/functions
[ -f ~/.bash/aliases ] && . ~/.bash/aliases


##
# Load host OS configuration

[ -f "$HOME/.bash/os_${HOST_OS}" ] && . "$HOME/.bash/os_${HOST_OS}"


##
# Initialization scripts

__garbage MAIN_BASH_INIT_DIR
MAIN_BASH_INIT_DIR=~/.bash/init.d

if [[ -d "$MAIN_BASH_INIT_DIR" && -r "$MAIN_BASH_INIT_DIR" \
      && -x "$MAIN_BASH_INIT_DIR" ]]; then
  for i in "$MAIN_BASH_INIT_DIR"/*; do
    [[ -f "$i" && -r "$i" ]] && . "$i"
  done
fi

local local_init_dir=~/.bash/local.d
if [[ -d "$local_init_dir" && -r "$local_init_dir" && -x "$local_init_dir" ]]; then
  for i in "$local_init_dir"/*; do
    [[ -f "$i" && -r "$i" ]] && . "$i"
  done
fi

unset i

# Collect local variables and functions.
__garbage
}

main
unset main

# ex: ts=2 sw=2 et filetype=sh
