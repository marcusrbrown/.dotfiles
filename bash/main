# .bash/main - Main Bash configuration
#
# This file is sourced from ~/.profile to pull in all custom shell configurations.
#
# Large portions taken from a variety of sources, including the dotfiles repos of
# github.com/{isaacs,rtomayko,twerth,sontek} to name a few.
#

main()
{
# try to avoid polluting the global namespace with lots of garbage.
# the *right* way to do this is to have everything inside functions,
# and use the "local" keyword.  But that would take some work to
# reorganize all my old messes.  So this is what I've got for now.
__garbage_list=""
__garbage () {
  local i
  if [ $# -eq 0 ]; then
    for i in ${__garbage_list}; do
      unset $i
    done
    unset __garbage_list
  else
    for i in "$@"; do
      __garbage_list="${__garbage_list} $i"
    done
  fi
}
__garbage __garbage


##
# Path utilities.

__garbage __set_path
__set_path () {
  local var="$1"
  local orig=$(eval 'echo $'$var)
  IFS=:
  orig=($orig)
  local p="$2"

  local path_elements=($p)
  unset IFS
  p=""
  local i
  local fixed
  for i in "${orig[@]}"; do
    if [ -d "$i" ]; then
      fixed="$fixed:$i"
    fi
  done
  fixed=" ${fixed//:/ : } :"
  for i in "${path_elements[@]}"; do
    if [ -d "$i" ]; then
      p="$p:$i"
      # strip out from the original set.
      fixed=${fixed/ $i :/}
    fi
  done
  fixed=${fixed// :/:}
  fixed=${fixed//: /:}
  # put the original at the front, but only the ones that aren't already present
  # This preserves the intended ordering, and allows env hijacking tricks like
  # nave and other subshell programs use.
  p="${fixed/:/}${p/:/}"
  export $var="$(echo $p)"
}

__garbage __form_paths
local path_roots=( "$HOME/" "$HOME/local/" /usr/local/ /opt/local/ /usr/ /opt/ / )
__form_paths () {
  local r p paths
  paths=""
  for r in "${path_roots[@]}"; do
    for p in "$@"; do
      paths="$paths:$r$p"
    done
  done
  echo ${paths/:/} # remove the first :
}

__set_path PATH "$(__form_paths bin sbin)"
__set_path LD_LIBRARY_PATH "$(__form_paths lib)"
# TODO: Needs mingw path fixup
#__set_path CLASSPATH "."
__set_path CDPATH ".:..:$HOME/git:$HOME/hg:$HOME"


##
# Shell and host environment.

# detect interactive shell
case "$-" in
  *i*) INTERACTIVE=yes ;;
  *)   unset INTERACTIVE ;;
esac

# detect login shell
case "$0" in
  -*) LOGIN=yes ;;
  *)  unset LOGIN ;;
esac

# detect remote shell
if [ -n "$SSH_CONNECTION" ]; then
  REMOTE=yes
else
  unset REMOTE
fi


##
# Various shell options

export HISTSIZE=10000
export HISTFILESIZE=1000000000
export HISTCONTROL=ignoreboth
export HISTIGNORE="&:cd:ls:ll:la:lal:[bf]g:exit"

if [ -n "$BASH" ]; then
  # see http://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html#The-Shopt-Builtin
  shopt -s cdspell                  # fix minor cd errors
  shopt -s checkhash                # check that a command exists in the hash table before executing it
  shopt -s checkwinsize             # update LINES and COLUMNS after each command to detect window size changes
  shopt -s cmdhist                  # save a multi-line command in a single history entry
  shopt -s expand_aliases           # expand aliases when not interactive
  shopt -s histappend               # append history instead of overwriting it
  shopt -s hostcomplete             # attempt hostname completion (on words containing '@')
  shopt -s nocaseglob               # case-insensitive filename match
  shopt -s no_empty_cmd_completion  # don't search PATH for command completion if the line is empty
fi


##
# ls

# if the dircolors utility is available, set that up to
__garbage __dircolors
__dircolors="$(type -P gdircolors dircolors | head -1)"
test -n "$dircolors" && {
  COLORS=/etc/DIR_COLORS
  test -e "/etc/DIR_COLORS.$TERM"   && COLORS="/etc/DIR_COLORS.$TERM"
  test -e "$HOME/.dircolors"        && COLORS="$HOME/.dircolors"
  test ! -e "$COLORS"               && COLORS=
  eval `$__dircolors --sh $COLORS`
}

# Setup the options that are always passed to ls
LS_COMMON="-hBG"

# Does ls support --color?
if (ls --color) &> /dev/null; then
  LS_COMMON="$LS_COMMON --color=auto"
else
  # No color, so put a slash at the end of directory names, etc. to differentiate.
  LS_COMMON="$LS_COMMON -F"
fi

test -n "$LS_COMMON" &&
alias ls="command ls $LS_COMMON"
alias ll="ls -l"
alias la="ls -a"
alias lal="ll -a"


##
# EDITOR and PAGER

EDITOR=vim
export EDITOR

if [ -n "$(command -v less)" ]; then
  # Less PAGER opts: Quit if fits on 1 screen, ignore case in searches w/no uppercase, output "raw" control chars,
  # chop long lines, highlight first new line after forward screen, don't use termcap init/deinit strings
  PAGER="less -FirSwX"
  # Less MANPAGER opts: Same as above except don't output "raw" control chars and squeeze multiple blank lines
  MANPAGER="less -FiRswX"
else
  PAGER=more
  MANPAGER=more
fi
export PAGER MANPAGER

alias l=$PAGER


##
# Terminal

if [ -n "$REMOTE" ]; then
  # Fix the terminal when shelling in from MSYS or Cygwin.
  case "$TERM" in
    msys*)
      # TODO: Make sure the host isn't MSYS or Cygwin.
      export TERM=xterm
      ;;
  esac
fi


##
# Prompt

# Only set the prompt if the shell is interactive.
if [ -n "$INTERACTIVE" ]; then
  NO_COLOR='\033[00m'
  RED='\033[01;31m'
  GREEN='\033[0;32m'
  YELLOW='\033[0;33m'
  BLUE='\033[01;34m'
  PURPLE='\033[01;35m'
  CYAN='\033[01;36m'
  WHITE='\033[01;37m'

  PATH_COLOR=$YELLOW
  HOST_COLOR=$PURPLE

  function __prompt()
  {
    local cwd=${PWD/$HOME/\~}

    case "$1" in
      title)
        echo -ne "\033]0;$HOSTNAME:$cwd\007"
        ;;

      path)
        local path=$cwd
        if [ ${#path} -gt 40 ]; then
          local d=$(basename "$path")
          path=$(dirname "$path")
          local i=$[ ${#path} - 40 ]
          path=...${path:$i}/$d
        fi
        echo -ne "${PATH_COLOR}${path}${NO_COLOR}"
        ;;

      host)
        local user=${USER:-$USERNAME}
        local host=${HOSTNAME}
        echo -ne "${HOST_COLOR}${user}@${host}${NO_COLOR}"
        ;;

      time)
        echo -ne "[${GREEN}$(date +"%R")${NO_COLOR}]"
        ;;

      status)
        local status
        if [ $__prompt_status -eq 0 ]; then
          status="\n\$${NO_COLOR} "
        else
          status="\n${RED}\$${NO_COLOR} "
        fi
        echo -ne "$status"
        ;;
    esac
  }

  PROMPT_COMMAND="__prompt_status=\$?; history -a"
  PS1="\$(__prompt title)\n\$(__prompt time) \$(__prompt host):\$(__prompt path) \$(__prompt status)"
fi


##
# ssh-agent

# Code for ~/.ssh/environment is originally from http://www.cygwin.com/ml/cygwin/2001-06/msg00537.html.

SSH_ENV="$HOME/.ssh/environment"

__garbage __start_ssh_agent
__start_ssh_agent()
{
  ssh-agent | sed 's/^echo/#echo/' > ${SSH_ENV}
  chmod 600 ${SSH_ENV}
  . ${SSH_ENV} > /dev/null
  if [ -n "$INTERACTIVE" ]; then
    # TODO: Not sure how useful this is when ssh-agent isn't already running, and we're not interactive...
    ssh-add
  fi
}

if [ -f "${SSH_ENV}" ]; then
  . ${SSH_ENV} > /dev/null
  ps -ef | grep ${SSH_AGENT_PID} | grep ssh-agent$ > /dev/null || {
    __start_ssh_agent
  }
else
  [ -d "$HOME/.ssh" ] || mkdir "$HOME/.ssh"
  __start_ssh_agent
fi


# Collect local variables and functions.
__garbage
}

main
unset main

# ex: ts=2 sw=2 et filetype=sh
